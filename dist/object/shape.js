"use strict";var t=require("../utils.js"),e=require("./display.js");require("../index-DdxX_nW5.js"),require("../coordinate/ObservablePoint.js");class s extends e.Display{constructor(t={}){super(t),this.emit("ready"),this._onUpdate()}addPath(...t){this.pathInstruction.push(...t),this.shouldUpdateBounds()}beginPath(){return this.addPath({action:"beginPath",args:[]}),this}closePath(){return this.addPath({action:"closePath",args:[]}),this}moveTo(...t){return this.addPath({action:"moveTo",args:[...t]}),this}lineTo(...t){return this.addPath({action:"lineTo",args:[...t]}),this}rect(...t){return this.addPath({action:"rect",args:[...t]}),this}roundRect(...t){return this.addPath({action:"roundRect",args:[...t]}),this}arc(...t){return this.addPath({action:"arc",args:[...t]}),this}arcTo(...t){return this.addPath({action:"arcTo",args:[...t]}),this}bezierCurveTo(...t){return this.addPath({action:"bezierCurveTo",args:[...t]}),this}ellipse(...t){return this.addPath({action:"ellipse",args:[...t]}),this}fillRect(...t){return this.addPath({action:"fillRect",args:[...t]}),this}strokeRect(...t){return this.addPath({action:"strokeRect",args:[...t]}),this}pathInstruction=[];get _shouldUpdate(){const t=this.pathInstruction.map((t=>t.action));return!(!t.includes("fill")&&!t.includes("stroke"))}_render(t){if(!t)throw new Error("CanvasRenderingContext2D is null or undefined");for(let e=0;e<this.pathInstruction.length;e++){const{action:s,args:i}=this.pathInstruction[e];if("fill"===s)i[0]?t.fillStyle=i[0]:this.fillStyle&&(t.fillStyle=this.fillStyle),t.fill();else if("stroke"===s){if(i[0]){const e=i[0];if("string"==typeof e||e instanceof CanvasGradient||e instanceof CanvasPattern)t.strokeStyle=e,t.lineWidth=this.strokeStyle.width??1;else{const s=e.color??this.strokeStyle.color;s&&(t.strokeStyle=s);const i=e.width??this.strokeStyle.width;i&&(t.lineWidth=i),e.dash?t.setLineDash(e.dash):t.setLineDash([])}}else this.strokeStyle.color&&(t.strokeStyle=this.strokeStyle.color),this.strokeStyle.width&&(t.lineWidth=this.strokeStyle.width),this.strokeStyle.dash?t.setLineDash(this.strokeStyle.dash):t.setLineDash([]);t.stroke()}else t[s](...i)}}_strokeStyle={};set strokeStyle(e){e!==this._strokeStyle&&("string"==typeof e||e instanceof CanvasGradient||e instanceof CanvasPattern?this._strokeStyle=t.createProxy({...this._strokeStyle,color:e},(()=>{this._onUpdate()})):(this._strokeStyle=t.createProxy(e,(()=>{this._onUpdate()})),this._onUpdate()))}get strokeStyle(){return this._strokeStyle}transformWidth=0;transformHeight=0;updateTransformBounds(){const e=[],s=[];for(let t=0;t<this.pathInstruction.length;t++){const{action:i,args:r}=this.pathInstruction[t];switch(i){case"lineTo":e.push(r[0]),s.push(r[1]);break;case"fillRect":case"strokeRect":case"roundRect":case"rect":{let t=0;"strokeRect"===i&&(t=this.strokeStyle.width??1),e.push(r[0]+r[2]+t),s.push(r[1]+r[2]+t);break}case"arc":case"arcTo":e.push(r[0]+r[2]),s.push(r[1]+r[2]);break;case"bezierCurveTo":e.push(r[2]+r[4]),s.push(r[3]+r[5]);break;case"ellipse":e.push(r[0]+r[2]),s.push(r[1]+r[3])}}this.transformWidth=t.calcDiff(e),this.transformHeight=t.calcDiff(s)}_fillStyle=null;set fillStyle(t){this._fillStyle=t,this._onUpdate()}get fillStyle(){return this._fillStyle}fill(t){return t&&this.addPath({action:"fill",args:[t]}),this}stroke(t){return this.addPath({action:"stroke",args:t?[t]:[]}),this}_filter="none";set filter(t){this._filter=t,this._onUpdate()}get filter(){return this._filter}}exports.Shape=s;
//# sourceMappingURL=shape.js.map
