{"version":3,"file":"shape.js","sources":["../../src/object/shape.ts"],"sourcesContent":["import type { AbstractStyle, IAbstractStyle, InputColor, StrokeInput } from '../style/abstract-style'\nimport type { FunctionKeys, ModifyReturnType } from '../types'\nimport { calcDiff, calcMax, createProxy } from '../utils'\nimport type { DisplayOptions } from './display'\nimport { Display } from './display'\n\ntype CanvasRenderingContext2DMethods = FunctionKeys<CanvasRenderingContext2D>\ninterface PathData<T extends CanvasRenderingContext2DMethods> {\n  action: T\n  args: any[]\n}\n\ntype Methods =\n  | 'beginPath'\n  | 'closePath'\n  | 'moveTo'\n  | 'fill'\n  | 'stroke'\n  | 'lineTo' //\n  | 'rect' //\n  | 'roundRect' //\n  | 'fillRect' //\n  | 'strokeRect'\n  | 'arc' //\n  | 'arcTo' //\n  | 'bezierCurveTo' //\n  | 'ellipse'\ntype PathInstruction = PathData<Methods>\nexport interface ShapeOptions extends DisplayOptions {\n\n}\n\ninterface IShape {\n  beginPath: () => Shape\n  closePath: () => Shape\n  moveTo: (...args: Parameters<CanvasRenderingContext2D['moveTo']>) => Shape\n  lineTo: (...args: Parameters<CanvasRenderingContext2D['lineTo']>) => Shape\n  stroke: (value?: StrokeInput | InputColor) => Shape\n  fill: (color?: InputColor) => Shape\n  rect: (...args: Parameters<CanvasRenderingContext2D['rect']>) => Shape\n  roundRect: (...args: Parameters<CanvasRenderingContext2D['roundRect']>) => Shape\n  arc: (...args: Parameters<CanvasRenderingContext2D['arc']>) => Shape\n  arcTo: (...args: Parameters<CanvasRenderingContext2D['arcTo']>) => Shape\n  bezierCurveTo: (...args: Parameters<CanvasRenderingContext2D['bezierCurveTo']>) => Shape\n  ellipse: (...args: Parameters<CanvasRenderingContext2D['ellipse']>) => Shape\n  fillRect: (...args: Parameters<CanvasRect['fillRect']>) => Shape\n  strokeRect: (...args: Parameters<CanvasRect['strokeRect']>) => Shape\n}\n\nexport class Shape extends Display implements IShape {\n  constructor(options: Partial<ShapeOptions> = {}) {\n    super(options)\n    this.emit('ready')\n    this._onUpdate()\n  }\n\n  addPath(...items: PathInstruction[]) {\n    this.pathInstruction.push(...items)\n    this.shouldUpdateBounds()\n  }\n\n  // CanvasRenderingContext2DMethods\n  beginPath(): Shape {\n    this.addPath({\n      action: 'beginPath',\n      args: [],\n    })\n    return this\n  }\n\n  closePath() {\n    this.addPath({\n      action: 'closePath',\n      args: [],\n    })\n    return this\n  }\n\n  moveTo(...args: Parameters<CanvasRenderingContext2D['lineTo']>) {\n    this.addPath({\n      action: 'moveTo',\n      args: [...args],\n    })\n    return this\n  }\n\n  lineTo(...args: Parameters<CanvasRenderingContext2D['lineTo']>) {\n    this.addPath({\n      action: 'lineTo',\n      args: [...args],\n    })\n    return this\n  }\n\n  rect(...args: Parameters<CanvasRenderingContext2D['rect']>) {\n    this.addPath({\n      action: 'rect',\n      args: [...args],\n    })\n    return this\n  }\n\n  roundRect(...args: Parameters<CanvasRenderingContext2D['roundRect']>) {\n    this.addPath({\n      action: 'roundRect',\n      args: [...args],\n    })\n    return this\n  }\n\n  arc(...args: Parameters<CanvasRenderingContext2D['arc']>) {\n    this.addPath({\n      action: 'arc',\n      args: [...args],\n    })\n    return this\n  }\n\n  arcTo(...args: Parameters<CanvasRenderingContext2D['arcTo']>) {\n    this.addPath({\n      action: 'arcTo',\n      args: [...args],\n    })\n    return this\n  }\n\n  bezierCurveTo(...args: Parameters<CanvasRenderingContext2D['bezierCurveTo']>) {\n    this.addPath({\n      action: 'bezierCurveTo',\n      args: [...args],\n    })\n    return this\n  }\n\n  ellipse(...args: Parameters<CanvasRenderingContext2D['ellipse']>) {\n    this.addPath({\n      action: 'ellipse',\n      args: [...args],\n    })\n    return this\n  }\n\n  fillRect(...args: Parameters<CanvasRect['fillRect']>) {\n    this.addPath({\n      action: 'fillRect',\n      args: [...args],\n    })\n    return this\n  }\n\n  strokeRect(...args: Parameters<CanvasRect['strokeRect']>) {\n    this.addPath({\n      action: 'strokeRect',\n      args: [...args],\n    })\n    return this\n  }\n\n  private pathInstruction: PathInstruction[] = []\n  get _shouldUpdate(): boolean {\n    const actions = this.pathInstruction.map(item => item.action)\n    if (actions.includes('fill')\n      || actions.includes('stroke')) {\n      return true\n    }\n    return false\n  }\n\n  protected _render(_ctx: CanvasRenderingContext2D): void {\n    if (!_ctx) {\n      throw new Error('CanvasRenderingContext2D is null or undefined')\n    }\n    for (let index = 0; index < this.pathInstruction.length; index++) {\n      const { action, args } = this.pathInstruction[index]\n      if (action === 'fill') {\n        if (args[0]) {\n          _ctx.fillStyle = args[0]\n        }\n        else if (this.fillStyle) {\n          _ctx.fillStyle = this.fillStyle\n        }\n        _ctx.fill()\n      }\n      else if (action === 'stroke') {\n        if (args[0]) {\n          const strokeInput = args[0] as StrokeInput | InputColor\n          if (typeof strokeInput === 'string'\n            || strokeInput instanceof CanvasGradient\n            || strokeInput instanceof CanvasPattern) {\n            _ctx.strokeStyle = strokeInput\n            _ctx.lineWidth = this.strokeStyle.width ?? 1\n          }\n          else {\n            const color = strokeInput.color ?? this.strokeStyle.color\n            if (color)\n              _ctx.strokeStyle = color\n\n            const width = strokeInput.width ?? this.strokeStyle.width\n\n            if (width)\n              _ctx.lineWidth = width\n\n            if (strokeInput.dash) {\n              _ctx.setLineDash(strokeInput.dash)\n            }\n            else {\n              _ctx.setLineDash([])\n            }\n          }\n        }\n        else {\n          if (this.strokeStyle.color)\n            _ctx.strokeStyle = this.strokeStyle.color\n          if (this.strokeStyle.width)\n            _ctx.lineWidth = this.strokeStyle.width\n          if (this.strokeStyle.dash) {\n            _ctx.setLineDash(this.strokeStyle.dash)\n          }\n          else {\n            _ctx.setLineDash([])\n          }\n        }\n        _ctx.stroke()\n      }\n      else {\n        ;(_ctx[action] as (...args: any[]) => void)(...args)\n      }\n    }\n  }\n\n  private _strokeStyle: StrokeInput = {}\n\n  set strokeStyle(value: StrokeInput | InputColor) {\n    if (value === this._strokeStyle)\n      return\n    if (\n      typeof value === 'string'\n      || value instanceof CanvasGradient\n      || value instanceof CanvasPattern\n    ) {\n      this._strokeStyle = createProxy({\n        ...this._strokeStyle,\n        color: value,\n      }, () => {\n        this._onUpdate()\n      })\n    }\n    else {\n      this._strokeStyle = createProxy(value, () => {\n        this._onUpdate()\n      })\n      this._onUpdate()\n    }\n  }\n\n  get strokeStyle(): StrokeInput {\n    return this._strokeStyle\n  }\n\n  transformWidth = 0\n  transformHeight = 0\n  updateTransformBounds(): void {\n    // 所有坐标的最大值放进来\n    const allX: number[] = []\n    const allY: number[] = []\n\n    for (let index = 0; index < this.pathInstruction.length; index++) {\n      const { action, args } = this.pathInstruction[index]\n      switch (action) {\n        case 'lineTo':\n          allX.push(args[0])\n          allY.push(args[1])\n          break\n        case 'fillRect':\n        case 'strokeRect':\n        case 'roundRect':\n        case 'rect':{\n          let strokeWeight = 0\n          if (action === 'strokeRect') {\n            strokeWeight = this.strokeStyle.width ?? 1\n          }\n          allX.push(args[0] + args[2] + strokeWeight)\n          allY.push(args[1] + args[2] + strokeWeight)\n          break\n        }\n        case 'arc':\n          allX.push(args[0] + args[2])\n          allY.push(args[1] + args[2])\n          break\n        case 'arcTo':\n          allX.push(args[0] + args[2])\n          allY.push(args[1] + args[2])\n          break\n        case 'bezierCurveTo':\n          allX.push(args[2] + args[4])\n          allY.push(args[3] + args[5])\n          break\n        case 'ellipse':\n          allX.push(args[0] + args[2])\n          allY.push(args[1] + args[3])\n      }\n    }\n    this.transformWidth = calcDiff(allX)\n    this.transformHeight = calcDiff(allY)\n  }\n\n  private _fillStyle: InputColor | null = null\n\n  set fillStyle(value) {\n    this._fillStyle = value\n    this._onUpdate()\n  }\n\n  get fillStyle() {\n    return this._fillStyle\n  }\n\n  fill(color?: IAbstractStyle['fill']) {\n    if (color) {\n      this.addPath({\n        action: 'fill',\n        args: [color],\n      })\n    }\n    return this\n  }\n\n  stroke(value?: StrokeInput | InputColor) {\n    this.addPath({\n      action: 'stroke',\n      args: value ? [value] : [],\n    })\n    return this\n  }\n\n  private _filter = 'none'\n\n  set filter(value) {\n    this._filter = value\n    this._onUpdate()\n  }\n\n  get filter() {\n    return this._filter\n  }\n}\n"],"names":["Shape","Display","constructor","options","super","this","emit","_onUpdate","addPath","items","pathInstruction","push","shouldUpdateBounds","beginPath","action","args","closePath","moveTo","lineTo","rect","roundRect","arc","arcTo","bezierCurveTo","ellipse","fillRect","strokeRect","_shouldUpdate","actions","map","item","includes","_render","_ctx","Error","index","length","fillStyle","fill","strokeInput","CanvasGradient","CanvasPattern","strokeStyle","lineWidth","width","color","dash","setLineDash","stroke","_strokeStyle","value","createProxy","transformWidth","transformHeight","updateTransformBounds","allX","allY","strokeWeight","calcDiff","_fillStyle","_filter","filter"],"mappings":"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"}