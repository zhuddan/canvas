{"version":3,"file":"text.mjs","sources":["../../src/object/text.ts"],"sourcesContent":["// import { interceptDirty } from '../common/intercept'\nimport type { TextStyleOptions } from '../style/text-style'\nimport { TextStyle } from '../style/text-style'\nimport { createCanvasFontString, formatValue } from '../utils'\nimport type { DisplayOptions } from './display'\nimport { Display } from './display'\n\nexport interface TextOptions extends DisplayOptions {\n  text: string\n  style?: Partial<TextStyleOptions> | TextStyle\n}\nexport class Text extends Display {\n  constructor(options: TextOptions) {\n    super(options)\n    if (options.style)\n      this.style = options.style\n    this.text = options.text ?? ''\n    this.emit('ready')\n    this._onUpdate()\n  }\n\n  private _style = new TextStyle()\n\n  set style(style: Partial<TextStyleOptions> | TextStyle) {\n    style = style || {}\n    this._style?.off('update', this._onUpdate, this)\n    this._style?.off('updateBounds', this.shouldUpdateBounds, this)\n    if (style instanceof TextStyle) {\n      this._style = style\n    }\n    else {\n      this._style = new TextStyle(style)\n    }\n    this._style.on('update', this._onUpdate, this)\n    this._style?.on('updateBounds', this.shouldUpdateBounds, this)\n    this._onUpdate()\n  }\n\n  get style(): TextStyle {\n    return this._style\n  }\n\n  private _text = ''\n\n  set text(text) {\n    if (this._text === text)\n      return\n    this._text = text\n    this._onUpdate()\n  }\n\n  get text() {\n    return this._text\n  }\n\n  get _shouldUpdate(): boolean {\n    return !!(this.style.fill) || !!(this.style.stroke.color && this.style.stroke.width)\n  }\n\n  getSplitText(ctx: CanvasRenderingContext2D) {\n    const texts = this.text.split('')\n    const splitText = []\n    let multilineText: string[] = []\n    for (let i = 0; i < texts.length; i++) {\n      const currentStr = texts[i]\n      multilineText.push(currentStr)\n      const rowStr = multilineText.join('')\n      if (ctx.measureText(rowStr).width > this.style.wordWrapWidth) {\n        multilineText.pop()\n        splitText.push(multilineText.join(''))\n        multilineText = [currentStr]\n        continue\n      }\n      if (i === texts.length - 1) {\n        splitText.push(rowStr)\n      }\n    }\n    return splitText\n  }\n\n  _render(ctx: CanvasRenderingContext2D) {\n    if (this.style.fill || (this.style.stroke?.color && this.style.stroke?.width)) {\n      this.style.render(ctx)\n      // 绘制单行文本\n      if (!this.style.wordWrap || !this.style.wordWrapWidth) {\n        if (this.style.fill) {\n          ctx.fillText(this.text, this.position.x, this.position.y)\n        }\n        if (this.style.stroke?.color && this.style.stroke?.width) {\n          ctx.strokeText(this.text, this.position.x, this.position.y)\n        }\n      }\n      else {\n        const splitText = this.getSplitText(ctx)\n        for (let i = 0; i < splitText.length; i++) {\n          const text = splitText[i]\n          if (this.style.fill) {\n            ctx.strokeText(text, this.position.x, this.position.y + i * this.style.lineHeight)\n          }\n          if (this.style.stroke?.color && this.style.stroke?.width) {\n            ctx.strokeText(text, this.position.x, this.position.y + i * this.style.lineHeight)\n          }\n        }\n      }\n    }\n  }\n\n  updateTransformBounds() {\n    if (!this._app)\n      return\n    this._app.onContext((ctx) => {\n      this.style.render(ctx)\n      if (!this.style.wordWrap || !this.style.wordWrapWidth) {\n        const measure = ctx.measureText(this.text)\n        this.transformWidth = measure.width\n        let height = Math.max(...[\n          measure.actualBoundingBoxDescent - measure.actualBoundingBoxAscent,\n          typeof this.style.fontSize == 'number' ? this.style.fontSize : Number.parseInt(`${this.style.fontSize}`),\n        ])\n        if (this.style.stroke && this.style.stroke.width) {\n          height += this.style.stroke.width\n        }\n        this.transformHeight = height\n      }\n      else {\n        const splitText = this.getSplitText(ctx)\n        this.transformWidth = this.style.wordWrapWidth\n        if (!splitText.length) {\n          this.transformHeight = 0\n          return\n        }\n        const measure = ctx.measureText(this.getSplitText(ctx)[0])\n        const lineHeight = this.style.lineHeight\n        let height = Math.max(...[\n          measure.actualBoundingBoxDescent - measure.actualBoundingBoxAscent,\n          lineHeight,\n        ])\n        if (this.style.stroke && this.style.stroke.width) {\n          height += this.style.stroke.width\n        }\n        if (splitText.length > 1) {\n          this.transformHeight = (splitText.length - 1) * lineHeight + height\n        }\n      }\n    })\n  }\n\n  transformWidth = 0\n\n  transformHeight = 0\n};\n"],"names":["Text","Display","constructor","options","super","style","this","text","emit","_onUpdate","_style","TextStyle","off","shouldUpdateBounds","on","_text","_shouldUpdate","stroke","color","width","getSplitText","ctx","texts","split","splitText","multilineText","i","length","currentStr","push","rowStr","join","measureText","wordWrapWidth","pop","_render","fill","render","wordWrap","strokeText","position","x","y","lineHeight","fillText","updateTransformBounds","_app","onContext","transformWidth","transformHeight","measure","height","Math","max","actualBoundingBoxDescent","actualBoundingBoxAscent","fontSize","Number","parseInt"],"mappings":"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"}