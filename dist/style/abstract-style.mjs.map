{"version":3,"file":"abstract-style.mjs","sources":["../../src/style/abstract-style.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3'\nimport { createProxy } from '../utils'\n\nexport type InputColor = CanvasRenderingContext2D['strokeStyle']\nexport type LineDash = Iterable<number>\nexport interface StrokeInput {\n  color?: InputColor\n  width?: number\n  dash?: LineDash\n}\n\n// | CanvasRenderingContext2D['strokeStyle']\nexport interface IAbstractStyle {\n  /**\n   * 填充颜色\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/fillStyle)\n   */\n  fill: CanvasRenderingContext2D['fillStyle'] | null\n  /**\n   * 描边颜色 当仅仅指定stroke 而未指定 fill 时 只会绘制镂空文字\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/strokeStyle)\n   */\n  stroke: StrokeInput\n  /**\n   * [CanvasRenderingContext2D.filter](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/filter)\n   */\n  filter: CanvasRenderingContext2D['filter']\n}\nexport abstract class AbstractStyle extends EventEmitter<{\n  update: []\n  updateBounds: []\n}> implements IAbstractStyle {\n  // private _strokeWeight = 0\n\n  // set strokeWeight(value) {\n  //   this._strokeWeight = value\n  //   this.update()\n  // }\n\n  // get strokeWeight() {\n  //   return this._strokeWeight\n  // }\n\n  private _fill = '#000'\n\n  set fill(value) {\n    this._fill = value\n    this.update()\n  }\n\n  get fill() {\n    return this._fill\n  }\n\n  private _stroke: StrokeInput = {}\n\n  set stroke(value: StrokeInput | InputColor) {\n    if (value === this._stroke)\n      return\n    if (\n      typeof value === 'string'\n      || value instanceof CanvasGradient\n      || value instanceof CanvasPattern\n    ) {\n      this._stroke = createProxy({\n        ...this._stroke,\n        color: value,\n      }, () => {\n        this.update()\n      })\n    }\n    else {\n      this._stroke = createProxy(value, () => {\n        this.update()\n      })\n      this.update()\n    }\n  }\n\n  get stroke(): StrokeInput {\n    return this._stroke\n  }\n\n  private _filter = 'none'\n\n  set filter(value) {\n    this._filter = value\n    this.update()\n  }\n\n  get filter() {\n    return this._filter\n  }\n\n  update() {\n    this.emit('update')\n  }\n\n  updateBounds() {\n    this.emit('updateBounds')\n  }\n\n  render(ctx: CanvasRenderingContext2D) {\n    if (this.stroke.color && this.stroke.width) {\n      ctx.lineWidth = this.stroke.width\n      ctx.strokeStyle = this.stroke.color\n    }\n    if (this.fill) {\n      ctx.fillStyle = this.fill\n    }\n    if (this.filter) {\n      ctx.filter = this.filter\n    }\n    return this\n  }\n\n  destroy() {\n    this.removeAllListeners()\n  }\n}\n"],"names":["AbstractStyle","EventEmitter","_fill","fill","value","this","update","_stroke","stroke","CanvasGradient","CanvasPattern","createProxy","color","_filter","filter","emit","updateBounds","render","ctx","width","lineWidth","strokeStyle","fillStyle","destroy","removeAllListeners"],"mappings":"oFA4BM,MAAgBA,UAAsBC,EAelCC,MAAQ,OAEhB,QAAIC,CAAKC,GACPC,KAAKH,MAAQE,EACbC,KAAKC,QACN,CAED,QAAIH,GACF,OAAOE,KAAKH,KACb,CAEOK,QAAuB,CAAA,EAE/B,UAAIC,CAAOJ,GACLA,IAAUC,KAAKE,UAGA,iBAAVH,GACJA,aAAiBK,gBACjBL,aAAiBM,cAEpBL,KAAKE,QAAUI,EAAY,IACtBN,KAAKE,QACRK,MAAOR,IACN,KACDC,KAAKC,QAAQ,KAIfD,KAAKE,QAAUI,EAAYP,GAAO,KAChCC,KAAKC,QAAQ,IAEfD,KAAKC,UAER,CAED,UAAIE,GACF,OAAOH,KAAKE,OACb,CAEOM,QAAU,OAElB,UAAIC,CAAOV,GACTC,KAAKQ,QAAUT,EACfC,KAAKC,QACN,CAED,UAAIQ,GACF,OAAOT,KAAKQ,OACb,CAED,MAAAP,GACED,KAAKU,KAAK,SACX,CAED,YAAAC,GACEX,KAAKU,KAAK,eACX,CAED,MAAAE,CAAOC,GAWL,OAVIb,KAAKG,OAAOI,OAASP,KAAKG,OAAOW,QACnCD,EAAIE,UAAYf,KAAKG,OAAOW,MAC5BD,EAAIG,YAAchB,KAAKG,OAAOI,OAE5BP,KAAKF,OACPe,EAAII,UAAYjB,KAAKF,MAEnBE,KAAKS,SACPI,EAAIJ,OAAST,KAAKS,QAEbT,IACR,CAED,OAAAkB,GACElB,KAAKmB,oBACN"}